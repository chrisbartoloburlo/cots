/**
 * Bing Maps Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package examples.bingmaps.api

import examples.bingmaps.model.ImageryMetadata
import examples.bingmaps.model.Location
import examples.bingmaps.core.JsonSupport._
import sttp.client3._
import sttp.model.Method

object DefaultApi {

def apply(baseUrl: String = "http://dev.virtualearth.net/REST/v1") = new DefaultApi(baseUrl)
}

class DefaultApi(baseUrl: String) {

  /**
   * Make a Local Search API request based on a string query by specifying a user location.
   * 
   * Expected answers:
   *   code 200 :  (Successful get imagery metadata.)
   * 
   * @param key BingMapsAPIKey
   * @param imagerySet The type of imagery for which you are requesting metadata.
   * @param centerPoint if imagerySet is Birdseye, BirdseyeWithLabels, or Streetside, centerPoint is required. The center point to use for the imagery metadata.
   * @param include Specifies to provide additional information about the imagery as part of the response.
   * @param orientation The orientation of the viewport to use for the imagery metadata. if imagerySet is Birdseye, orientation is required
   * @param uriScheme Specifies the scheme that image URL in the response should use.
   * @param zoomLevel The level of zoom to use for the imagery metadata. if imagerySet is Road, Aerial, or AerialWithLabels, zoomLevel is required
   * @param mapLayer A display layer that renders on top of the imagery set.
   */
  def imageryBasicMetadataImagerySetCenterPointGet(key: String, imagerySet: String, centerPoint: String, include: Option[String] = None, orientation: Option[Double] = None, uriScheme: Option[String] = None, zoomLevel: Option[Int] = None, mapLayer: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/BasicMetadata/${imagerySet}/${centerPoint}?key=${ key }&include=${ include.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&uriScheme=${ uriScheme.getOrElse(None) }&zoomLevel=${ zoomLevel.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get a map that is centered at a specified point
   * 
   * Expected answers:
   *   code 200 :  (Get a map that is centered at a specified point)
   * 
   * @param key BingMapsAPIKey
   * @param centerPoint A point on the Earth where the map is centered.
   * @param imagerySet The type of imagery.
   * @param zoomLevel The level of zoom to display.
   * @param declutterPins Specifies whether to change the display of overlapping pushpins so that they display separately on a map.
   * @param dpi  Specifies the resolution of the labels on the image to retrieve.
   * @param drawCurve Used to insert lines, curves, circles, and polygons over an image.
   * @param format The image format to use for the static map.
   * @param heading  Desired camera heading in degrees, clockwise from north.
   * @param mapArea The geographic area to display on the map.
   * @param mapLayer A display layer that renders on top of the imagery set.
   * @param mapSize The width and height in pixels of the static map output.
   * @param mapMetadata Specifies whether to return metadata for the static map instead of the image.
   * @param pitch Controls the camera pitch angle.
   * @param orientation  The orientation of view for Bird's Eye imagery.
   * @param pushpin One or more pushpin locations to display on the map.
   * @param query A query string that is used to determine the map location to display.
   * @param fieldOfView Specifies the horizontal field of view in degrees that should be shown in the image. Either 'fieldOfView' or 'zoomLevel' should be specified, not both.
   * @param highlightEntity Highlights a polygon for an entity.
   * @param style Specifies a custom map style to apply to the road maps.
   */
  def imageryMapImagerySetCenterPointZoomLevelGet(key: String, centerPoint: String, imagerySet: String, zoomLevel: Int, declutterPins: Option[Int] = None, dpi: Option[String] = None, drawCurve: Option[String] = None, format: Option[String] = None, heading: Option[org.json4s.JValue] = None, mapArea: Option[String] = None, mapLayer: Option[String] = None, mapSize: Option[String] = None, mapMetadata: Option[Int] = None, pitch: Option[org.json4s.JValue] = None, orientation: Option[org.json4s.JValue] = None, pushpin: Option[String] = None, query: Option[String] = None, fieldOfView: Option[Int] = None, highlightEntity: Option[Int] = None, style: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Map/${imagerySet}/${centerPoint}/${zoomLevel}?key=${ key }&declutterPins=${ declutterPins.getOrElse(None) }&dpi=${ dpi.getOrElse(None) }&drawCurve=${ drawCurve.getOrElse(None) }&format=${ format.getOrElse(None) }&heading=${ heading.getOrElse(None) }&mapArea=${ mapArea.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }&mapSize=${ mapSize.getOrElse(None) }&mapMetadata=${ mapMetadata.getOrElse(None) }&pitch=${ pitch.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&pushpin=${ pushpin.getOrElse(None) }&query=${ query.getOrElse(None) }&fieldOfView=${ fieldOfView.getOrElse(None) }&highlightEntity=${ highlightEntity.getOrElse(None) }&style=${ style.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get a map that is centered at the specified point and that displays a route
   * 
   * Expected answers:
   *   code 200 :  (Get a map that shows a specified map area)
   * 
   * @param key BingMapsAPIKey
   * @param centerPoint A point on the Earth where the map is centered.
   * @param imagerySet The type of imagery.
   * @param travelMode The mode of travel for the route.
   * @param waypoint0 Specifies two or more locations that define the route and that are in sequential order
   * @param waypoint1 Specifies two or more locations that define the route and that are in sequential order
   * @param zoomLevel The level of zoom to display.
   * @param format The image format to use for the static map.
   * @param avoid Specifies the road types to minimize or avoid when the route is created for the driving travel mode.
   * @param distanceBeforeFirstTurn  Specifies the distance before the first turn is allowed in the route. if travelMode is Driving, distanceBeforeFirstTurn is required
   * @param dateTime The timeType parameter identifies the desired transit time, such as arrival time or departure time. if travelMode is Transit, dateTime is required
   * @param maxSolutions Specifies the maximum number of transit routes to return. if travelMode is Transit or Driving, maxSolutions is required
   * @param optimize Specifies what parameters to use to optimize the route on the map.
   * @param timeType Specifies how to interpret the date and transit time value that is specified by the dateTime parameter. if travelMode is Transit, timeType is required
   * @param pushpin One or more pushpin locations to display on the map.
   * @param mapArea The geographic area to display on the map.
   * @param mapLayer A display layer that renders on top of the imagery set.
   * @param mapSize The width and height in pixels of the static map output.
   * @param mapMetadata Specifies whether to return metadata for the static map instead of the image.
   */
  def imageryMapImagerySetCenterPointZoomLevelRoutesTravelModeGet(key: String, centerPoint: String, imagerySet: String, travelMode: String, waypoint0: String, waypoint1: String, zoomLevel: Int, format: Option[String] = None, avoid: Option[String] = None, distanceBeforeFirstTurn: Option[Int] = None, dateTime: Option[String] = None, maxSolutions: Option[Int] = None, optimize: Option[String] = None, timeType: Option[String] = None, pushpin: Option[String] = None, mapArea: Option[String] = None, mapLayer: Option[String] = None, mapSize: Option[String] = None, mapMetadata: Option[Int] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Map/${imagerySet}/${centerPoint}/${zoomLevel}/Routes/${travelMode}?key=${ key }&format=${ format.getOrElse(None) }&avoid=${ avoid.getOrElse(None) }&distanceBeforeFirstTurn=${ distanceBeforeFirstTurn.getOrElse(None) }&dateTime=${ dateTime.getOrElse(None) }&maxSolutions=${ maxSolutions.getOrElse(None) }&optimize=${ optimize.getOrElse(None) }&timeType=${ timeType.getOrElse(None) }&waypoint.0=${ waypoint0 }&waypoint.1=${ waypoint1 }&pushpin=${ pushpin.getOrElse(None) }&mapArea=${ mapArea.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }&mapSize=${ mapSize.getOrElse(None) }&mapMetadata=${ mapMetadata.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get a map that shows a specified map area
   * 
   * Expected answers:
   *   code 200 :  (Get a map that shows a specified map area)
   * 
   * @param key BingMapsAPIKey
   * @param imagerySet The type of imagery.
   * @param declutterPins Specifies whether to change the display of overlapping pushpins so that they display separately on a map.
   * @param dpi  Specifies the resolution of the labels on the image to retrieve.
   * @param drawCurve Used to insert lines, curves, circles, and polygons over an image.
   * @param format The image format to use for the static map.
   * @param heading  Desired camera heading in degrees, clockwise from north.
   * @param mapArea The geographic area to display on the map.
   * @param mapLayer A display layer that renders on top of the imagery set.
   * @param mapSize The width and height in pixels of the static map output.
   * @param mapMetadata Specifies whether to return metadata for the static map instead of the image.
   * @param pitch Controls the camera pitch angle.
   * @param orientation  The orientation of view for Bird's Eye imagery.
   * @param pushpin One or more pushpin locations to display on the map.
   * @param query A query string that is used to determine the map location to display.
   * @param fieldOfView Specifies the horizontal field of view in degrees that should be shown in the image.
   * @param highlightEntity Highlights a polygon for an entity.
   * @param style Specifies a custom map style to apply to the road maps.
   */
  def imageryMapImagerySetGet(key: String, imagerySet: String, declutterPins: Option[Int] = None, dpi: Option[String] = None, drawCurve: Option[String] = None, format: Option[String] = None, heading: Option[org.json4s.JValue] = None, mapArea: Option[String] = None, mapLayer: Option[String] = None, mapSize: Option[String] = None, mapMetadata: Option[Int] = None, pitch: Option[org.json4s.JValue] = None, orientation: Option[org.json4s.JValue] = None, pushpin: Option[String] = None, query: Option[String] = None, fieldOfView: Option[Int] = None, highlightEntity: Option[Int] = None, style: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Map/${imagerySet}?key=${ key }&declutterPins=${ declutterPins.getOrElse(None) }&dpi=${ dpi.getOrElse(None) }&drawCurve=${ drawCurve.getOrElse(None) }&format=${ format.getOrElse(None) }&heading=${ heading.getOrElse(None) }&mapArea=${ mapArea.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }&mapSize=${ mapSize.getOrElse(None) }&mapMetadata=${ mapMetadata.getOrElse(None) }&pitch=${ pitch.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&pushpin=${ pushpin.getOrElse(None) }&query=${ query.getOrElse(None) }&fieldOfView=${ fieldOfView.getOrElse(None) }&highlightEntity=${ highlightEntity.getOrElse(None) }&style=${ style.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get a map that shows a specified map area
   * 
   * Expected answers:
   *   code 200 :  (Get a map that shows a specified map area)
   * 
   * @param key BingMapsAPIKey
   * @param imagerySet The type of imagery.
   * @param query A query string that is used to determine the map location to display.
   * @param declutterPins Specifies whether to change the display of overlapping pushpins so that they display separately on a map.
   * @param dpi  Specifies the resolution of the labels on the image to retrieve.
   * @param drawCurve Used to insert lines, curves, circles, and polygons over an image.
   * @param format The image format to use for the static map.
   * @param heading  Desired camera heading in degrees, clockwise from north.
   * @param mapArea The geographic area to display on the map.
   * @param mapLayer A display layer that renders on top of the imagery set.
   * @param mapSize The width and height in pixels of the static map output.
   * @param mapMetadata Specifies whether to return metadata for the static map instead of the image.
   * @param pitch Controls the camera pitch angle.
   * @param orientation  The orientation of view for Bird's Eye imagery.
   * @param pushpin One or more pushpin locations to display on the map.
   * @param fieldOfView Specifies the horizontal field of view in degrees that should be shown in the image. 
   * @param highlightEntity Highlights a polygon for an entity.
   * @param style Specifies a custom map style to apply to the road maps.
   */
  def imageryMapImagerySetQueryGet(key: String, imagerySet: String, query: String, declutterPins: Option[Int] = None, dpi: Option[String] = None, drawCurve: Option[String] = None, format: Option[String] = None, heading: Option[org.json4s.JValue] = None, mapArea: Option[String] = None, mapLayer: Option[String] = None, mapSize: Option[String] = None, mapMetadata: Option[Int] = None, pitch: Option[org.json4s.JValue] = None, orientation: Option[org.json4s.JValue] = None, pushpin: Option[String] = None, fieldOfView: Option[Int] = None, highlightEntity: Option[Int] = None, style: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Map/${imagerySet}/${query}?key=${ key }&declutterPins=${ declutterPins.getOrElse(None) }&dpi=${ dpi.getOrElse(None) }&drawCurve=${ drawCurve.getOrElse(None) }&format=${ format.getOrElse(None) }&heading=${ heading.getOrElse(None) }&mapArea=${ mapArea.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }&mapSize=${ mapSize.getOrElse(None) }&mapMetadata=${ mapMetadata.getOrElse(None) }&pitch=${ pitch.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&pushpin=${ pushpin.getOrElse(None) }&fieldOfView=${ fieldOfView.getOrElse(None) }&highlightEntity=${ highlightEntity.getOrElse(None) }&style=${ style.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get a map that is centered at the specified point and that displays a route
   * 
   * Expected answers:
   *   code 200 :  (Get a map that shows a specified map area)
   * 
   * @param key BingMapsAPIKey
   * @param imagerySet The type of imagery.
   * @param travelMode The mode of travel for the route.
   * @param waypoint0 Specifies two or more locations that define the route and that are in sequential order
   * @param waypoint1 Specifies two or more locations that define the route and that are in sequential order
   * @param zoomLevel The level of zoom to display.
   * @param avoid Specifies the road types to minimize or avoid when the route is created for the driving travel mode.
   * @param format The image format to use for the static map.
   * @param distanceBeforeFirstTurn  Specifies the distance before the first turn is allowed in the route. if travelMode is Driving, distanceBeforeFirstTurn is required
   * @param dateTime The timeType parameter identifies the desired transit time, such as arrival time or departure time. if travelMode is Transit, dateTime is required
   * @param maxSolutions Specifies the maximum number of transit routes to return. if travelMode is Transit, maxSolutions is required
   * @param optimize Specifies what parameters to use to optimize the route on the map.
   * @param timeType Specifies how to interpret the date and transit time value that is specified by the dateTime parameter. if travelMode is Transit, timeType is required
   * @param pushpin One or more pushpin locations to display on the map.
   * @param mapArea The geographic area to display on the map.
   * @param mapLayer A display layer that renders on top of the imagery set.
   * @param mapSize The width and height in pixels of the static map output.
   * @param mapMetadata Specifies whether to return metadata for the static map instead of the image.
   */
  def imageryMapImagerySetRoutesTravelModeGet(key: String, imagerySet: String, travelMode: String, waypoint0: String, waypoint1: String, zoomLevel: Int, avoid: Option[String] = None, format: Option[String] = None, distanceBeforeFirstTurn: Option[Int] = None, dateTime: Option[String] = None, maxSolutions: Option[Int] = None, optimize: Option[String] = None, timeType: Option[String] = None, pushpin: Option[String] = None, mapArea: Option[String] = None, mapLayer: Option[String] = None, mapSize: Option[String] = None, mapMetadata: Option[Int] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Map/${imagerySet}/Routes/${travelMode}?key=${ key }&avoid=${ avoid.getOrElse(None) }&format=${ format.getOrElse(None) }&distanceBeforeFirstTurn=${ distanceBeforeFirstTurn.getOrElse(None) }&dateTime=${ dateTime.getOrElse(None) }&maxSolutions=${ maxSolutions.getOrElse(None) }&optimize=${ optimize.getOrElse(None) }&timeType=${ timeType.getOrElse(None) }&waypoint.0=${ waypoint0 }&waypoint.1=${ waypoint1 }&zoomLevel=${ zoomLevel }&pushpin=${ pushpin.getOrElse(None) }&mapArea=${ mapArea.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }&mapSize=${ mapSize.getOrElse(None) }&mapMetadata=${ mapMetadata.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get a map that shows a specified map area
   * 
   * Expected answers:
   *   code 200 :  (Get a map that shows a specified map area)
   * 
   * @param key BingMapsAPIKey
   * @param address A query string that is used to determine the map location to display.
   * @param zoomLevel The level of zoom to display.
   * @param declutterPins Specifies whether to change the display of overlapping pushpins so that they display separately on a map.
   * @param dpi  Specifies the resolution of the labels on the image to retrieve.
   * @param drawCurve Used to insert lines, curves, circles, and polygons over an image.
   * @param format The image format to use for the static map.
   * @param heading  Desired camera heading in degrees, clockwise from north.
   * @param mapArea The geographic area to display on the map.
   * @param mapLayer A display layer that renders on top of the imagery set.
   * @param mapSize The width and height in pixels of the static map output.
   * @param mapMetadata Specifies whether to return metadata for the static map instead of the image.
   * @param pitch Controls the camera pitch angle.
   * @param orientation  The orientation of view for Bird's Eye imagery.
   * @param pushpin One or more pushpin locations to display on the map.
   * @param fieldOfView Specifies the horizontal field of view in degrees that should be shown in the image. Either 'fieldOfView' or 'zoomLevel' should be specified, not both.
   * @param highlightEntity Highlights a polygon for an entity.
   * @param style Specifies a custom map style to apply to the road maps.
   */
  def imageryMapStreetsideAddressGet(key: String, address: String, zoomLevel: Int, declutterPins: Option[Int] = None, dpi: Option[String] = None, drawCurve: Option[String] = None, format: Option[String] = None, heading: Option[org.json4s.JValue] = None, mapArea: Option[String] = None, mapLayer: Option[String] = None, mapSize: Option[String] = None, mapMetadata: Option[Int] = None, pitch: Option[org.json4s.JValue] = None, orientation: Option[org.json4s.JValue] = None, pushpin: Option[String] = None, fieldOfView: Option[Int] = None, highlightEntity: Option[Int] = None, style: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Map/Streetside/${address}?key=${ key }&declutterPins=${ declutterPins.getOrElse(None) }&dpi=${ dpi.getOrElse(None) }&drawCurve=${ drawCurve.getOrElse(None) }&format=${ format.getOrElse(None) }&heading=${ heading.getOrElse(None) }&mapArea=${ mapArea.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }&mapSize=${ mapSize.getOrElse(None) }&mapMetadata=${ mapMetadata.getOrElse(None) }&pitch=${ pitch.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&pushpin=${ pushpin.getOrElse(None) }&zoomLevel=${ zoomLevel }&fieldOfView=${ fieldOfView.getOrElse(None) }&highlightEntity=${ highlightEntity.getOrElse(None) }&style=${ style.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get a map that shows a specified map area
   * 
   * Expected answers:
   *   code 200 :  (Get a map that shows a specified map area)
   * 
   * @param key BingMapsAPIKey
   * @param centerPoint A point on the Earth where the map is centered.
   * @param zoomLevel The level of zoom to display.
   * @param declutterPins Specifies whether to change the display of overlapping pushpins so that they display separately on a map.
   * @param dpi  Specifies the resolution of the labels on the image to retrieve.
   * @param drawCurve Used to insert lines, curves, circles, and polygons over an image.
   * @param format The image format to use for the static map.
   * @param heading  Desired camera heading in degrees, clockwise from north.
   * @param mapArea The geographic area to display on the map.
   * @param mapLayer A display layer that renders on top of the imagery set.
   * @param mapSize The width and height in pixels of the static map output.
   * @param mapMetadata Specifies whether to return metadata for the static map instead of the image.
   * @param pitch Controls the camera pitch angle.
   * @param orientation  The orientation of view for Bird's Eye imagery.
   * @param pushpin One or more pushpin locations to display on the map.
   * @param fieldOfView Specifies the horizontal field of view in degrees that should be shown in the image. Either 'fieldOfView' or 'zoomLevel' should be specified, not both.
   * @param highlightEntity Highlights a polygon for an entity.
   * @param style Specifies a custom map style to apply to the road maps.
   */
  def imageryMapStreetsideCenterPointZoomLevelGet(key: String, centerPoint: String, zoomLevel: Int, declutterPins: Option[Int] = None, dpi: Option[String] = None, drawCurve: Option[String] = None, format: Option[String] = None, heading: Option[org.json4s.JValue] = None, mapArea: Option[String] = None, mapLayer: Option[String] = None, mapSize: Option[String] = None, mapMetadata: Option[Int] = None, pitch: Option[org.json4s.JValue] = None, orientation: Option[org.json4s.JValue] = None, pushpin: Option[String] = None, fieldOfView: Option[Int] = None, highlightEntity: Option[Int] = None, style: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Map/Streetside/${centerPoint}/${zoomLevel}?key=${ key }&declutterPins=${ declutterPins.getOrElse(None) }&dpi=${ dpi.getOrElse(None) }&drawCurve=${ drawCurve.getOrElse(None) }&format=${ format.getOrElse(None) }&heading=${ heading.getOrElse(None) }&mapArea=${ mapArea.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }&mapSize=${ mapSize.getOrElse(None) }&mapMetadata=${ mapMetadata.getOrElse(None) }&pitch=${ pitch.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&pushpin=${ pushpin.getOrElse(None) }&fieldOfView=${ fieldOfView.getOrElse(None) }&highlightEntity=${ highlightEntity.getOrElse(None) }&style=${ style.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Make a Local Search API request based on a string query by specifying a user location.
   * 
   * Expected answers:
   *   code 200 : ImageryMetadata (Successful get imagery metadata.)
   * 
   * @param key BingMapsAPIKey
   * @param imagerySet The type of imagery for which you are requesting metadata.
   * @param centerPoint if imagerySet is Birdseye, BirdseyeWithLabels, or Streetside, centerPoint is required. The center point to use for the imagery metadata.
   * @param include Specifies to provide additional information about the imagery as part of the response.
   * @param orientation The orientation of the viewport to use for the imagery metadata. if imagerySet is Birdseye, orientation is required
   * @param uriScheme Specifies the scheme that image URL in the response should use.
   * @param zoomLevel The level of zoom to use for the imagery metadata. if imagerySet is Road, Aerial, or AerialWithLabels, zoomLevel is required
   * @param mapLayer A display layer that renders on top of the imagery set.
   */
  def imageryMetadataImagerySetCenterPointGet(key: String, imagerySet: String, centerPoint: String, include: Option[String] = None, orientation: Option[Double] = None, uriScheme: Option[String] = None, zoomLevel: Option[Int] = None, mapLayer: Option[String] = None
): Request[Either[ResponseException[String, Exception], ImageryMetadata], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Metadata/${imagerySet}/${centerPoint}?key=${ key }&include=${ include.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&uriScheme=${ uriScheme.getOrElse(None) }&zoomLevel=${ zoomLevel.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[ImageryMetadata])

  /**
   * Make a Local Search API request based on a string query by specifying a user location.
   * 
   * Expected answers:
   *   code 200 :  (Successful get imagery metadata.)
   * 
   * @param key BingMapsAPIKey
   * @param imagerySet The type of imagery for which you are requesting metadata.
   * @param include Specifies to provide additional information about the imagery as part of the response.
   * @param orientation The orientation of the viewport to use for the imagery metadata. if imagerySet is Birdseye, orientation is required
   * @param uriScheme Specifies the scheme that image URL in the response should use.
   * @param mapLayer A display layer that renders on top of the imagery set.
   */
  def imageryMetadataImagerySetGet(key: String, imagerySet: String, include: Option[String] = None, orientation: Option[Double] = None, uriScheme: Option[String] = None, mapLayer: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Imagery/Metadata/${imagerySet}?key=${ key }&include=${ include.getOrElse(None) }&orientation=${ orientation.getOrElse(None) }&uriScheme=${ uriScheme.getOrElse(None) }&mapLayer=${ mapLayer.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Make a Local Search API request based on a string query by specifying a user location.
   * 
   * Expected answers:
   *   code 200 :  (Successful Local Search API requests return a list of LocalSearch resources.)
   * 
   * @param key BingMapsAPIKey
   * @param query if searching by query. The query used to search for local entities.
   * @param `type` Either query or type is required, not both
   * @param maxResults  Specifies the maximum number of locations to return in the response.
   * @param userCircularMapView A circular geographic region
   * @param userLocation If userMapView and userCircularMapView are not present, userLocation is required
   * @param userMapView If userMapView and userCircularView are not present, userLocation is required
   */
  def localSearchGet(key: String, query: Option[String] = None, `type`: Option[String] = None, maxResults: Option[Int] = None, userCircularMapView: Option[String] = None, userLocation: Option[String] = None, userMapView: Option[String] = None
): Request[Either[ResponseException[String, Exception], Unit], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/LocalSearch?key=${ key }&query=${ query.getOrElse(None) }&type=${ `type`.getOrElse(None) }&maxResults=${ maxResults.getOrElse(None) }&userCircularMapView=${ userCircularMapView.getOrElse(None) }&userLocation=${ userLocation.getOrElse(None) }&userMapView=${ userMapView.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Unit])

  /**
   * Get an address for a specified point (latitude and longitude).
   * 
   * Expected answers:
   *   code 200 : Location (One or more Location resources are returned in the response when you make a request by using these URL templates)
   * 
   * @param key BingMapsAPIKey
   * @param point The coordinates of the location that you want to reverse geocode
   * @param radius Search radius in kilometers (KM).
   * @param top  The maximum number of entities returned.
   * @param dateTime  Date and time at which the location is visited, in UTC format
   * @param distanceUnit  Unit for the radius parameter
   * @param verboseplacenames If true: admin1 names will be in expanded form
   * @param includeEntityTypes Specifies the entity types that you want to return in the response
   * @param `type` if includeEntityTypes is businessAndPOI, type is required.
   * @param output Output format for the response.
   */
  def locationRecogPointGet(key: String, point: String, radius: Option[Int] = None, top: Option[Int] = None, dateTime: Option[String] = None, distanceUnit: Option[String] = None, verboseplacenames: Option[Boolean] = None, includeEntityTypes: Option[String] = None, `type`: Option[String] = None, output: Option[String] = None
): Request[Either[ResponseException[String, Exception], Location], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/LocationRecog/${point}?key=${ key }&radius=${ radius.getOrElse(None) }&top=${ top.getOrElse(None) }&dateTime=${ dateTime.getOrElse(None) }&distanceUnit=${ distanceUnit.getOrElse(None) }&verboseplacenames=${ verboseplacenames.getOrElse(None) }&includeEntityTypes=${ includeEntityTypes.getOrElse(None) }&type=${ `type`.getOrElse(None) }&output=${ output.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Location])

  /**
   * Get the latitude and longitude coordinates based on a set of address values for any country
   * 
   * Expected answers:
   *   code 200 : Location (One or more Location resources are returned in the response when you make a request by using these URL templates)
   * 
   * @param key BingMapsAPIKey
   * @param adminDistrict The subdivision name in the country or region for an address. This element is typically treated as the first order administrative subdivision, but in some cases it is the second, third, or fourth order subdivision in a country, dependency, or region.
   * @param locality  The locality, such as the city or neighborhood, that corresponds to an address.
   * @param postalCode  The post code, postal code, or ZIP Code of an address.
   * @param addressLine  The official street line of an address relative to the area, as specified by the Locality, or PostalCode, properties. Typical use of this element would be to provide a street address or any official address.
   * @param countryRegion The ISO country code for the country.
   * @param includeNeighborhood Specifies to include the neighborhood in the response when it is available.
   * @param include Specifies additional values to include.
   * @param maxResults Specifies the maximum number of locations to return in the response.
   * @param strictMatch  Restricts the geocode result to the country or region that is specified in the countryRegion field and the state, province or territory specified in the adminDistrict field.
   */
  def locationsGet(key: String, adminDistrict: Option[String] = None, locality: Option[String] = None, postalCode: Option[String] = None, addressLine: Option[String] = None, countryRegion: Option[String] = None, includeNeighborhood: Option[Int] = None, include: Option[String] = None, maxResults: Option[Int] = None, strictMatch: Option[Int] = None
): Request[Either[ResponseException[String, Exception], Location], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Locations?key=${ key }&adminDistrict=${ adminDistrict.getOrElse(None) }&locality=${ locality.getOrElse(None) }&postalCode=${ postalCode.getOrElse(None) }&addressLine=${ addressLine.getOrElse(None) }&countryRegion=${ countryRegion.getOrElse(None) }&includeNeighborhood=${ includeNeighborhood.getOrElse(None) }&include=${ include.getOrElse(None) }&maxResults=${ maxResults.getOrElse(None) }&strictMatch=${ strictMatch.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Location])

  /**
   * Get an address for a specified point (latitude and longitude).
   * 
   * Expected answers:
   *   code 200 : Location (One or more Location resources are returned in the response when you make a request by using these URL templates)
   * 
   * @param key BingMapsAPIKey
   * @param point The coordinates of the location that you want to reverse geocode
   * @param includeEntityTypes Specifies the entity types that you want to return in the response
   * @param includeNeighborhood Specifies to include the neighborhood in the response when it is available.
   * @param include Specifies additional values to include.
   * @param verboseplacenames If true: AdminDistrict names will be in expanded
   */
  def locationsPointGet(key: String, point: String, includeEntityTypes: Option[String] = None, includeNeighborhood: Option[Int] = None, include: Option[String] = None, verboseplacenames: Option[Boolean] = None
): Request[Either[ResponseException[String, Exception], Location], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Locations/${point}?key=${ key }&includeEntityTypes=${ includeEntityTypes.getOrElse(None) }&includeNeighborhood=${ includeNeighborhood.getOrElse(None) }&include=${ include.getOrElse(None) }&verboseplacenames=${ verboseplacenames.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Location])

  /**
   * Return latitude and longitude coordinates for a location specified by a query
   * 
   * Expected answers:
   *   code 200 : Location (One or more Location resources are returned in the response when you make a request by using these URL templates)
   * 
   * @param key BingMapsAPIKey
   * @param query A string that contains information about a location, such as an address or landmark name.
   * @param includeNeighborhood Specifies to include the neighborhood in the response when it is available.
   * @param include Specifies additional values to include.
   * @param maxResults Specifies the maximum number of locations to return in the response.
   */
  def locationsQueryGet(key: String, query: String, includeNeighborhood: Option[Int] = None, include: Option[String] = None, maxResults: Option[Int] = None
): Request[Either[ResponseException[String, Exception], Location], Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/Locations/${query}?key=${ key }&includeNeighborhood=${ includeNeighborhood.getOrElse(None) }&include=${ include.getOrElse(None) }&maxResults=${ maxResults.getOrElse(None) }")
      .contentType("application/json")
      .response(asJson[Location])

}
